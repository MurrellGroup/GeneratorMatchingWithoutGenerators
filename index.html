<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generator Matching without Generators (rough draft)</title>
    
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                macros: {
                    R: "\\mathbb{R}",
                    E: "\\mathbb{E}",
                    Var: "\\mathrm{Var}",
                    Prob: "\\mathbb{P}"
                }
            }
        };
    </script>

    <style>
        :root {
            --text-color: #333;
            --bg-color: #fcfcfc;
            --primary-color: #0056b3;
            --accent-color: #d63384;
            --code-bg: #f1f3f5;
            --border-color: #e9ecef;
        }

        body {
            font-family: "Georgia", "Times New Roman", serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        h1, h2, h3 {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: #111;
            margin-top: 2rem;
        }

        h1 { font-size: 2.2rem; margin-bottom: 0.5rem; text-align: center; }
        h2 { border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; }
        
        .abstract {
            background-color: var(--code-bg);
            padding: 1.5rem;
            border-radius: 8px;
            font-style: italic;
            margin: 2rem 0;
            border-left: 4px solid var(--primary-color);
        }

        .interactive-figure {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            margin: 2rem 0;
            padding: 1rem;
            text-align: center;
        }

        canvas {
            display: block;
            margin: 10px auto;
            background: #fff;
            border: 1px solid #eee;
            cursor: crosshair;
            max-width: 100%;
        }

        .controls {
            margin-top: 15px;
            font-family: -apple-system, sans-serif;
            font-size: 0.9rem;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        button {
            padding: 6px 12px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.85rem;
        }

        button:hover { background: #004494; }
        button.secondary { background: #6c757d; }
        button.secondary:hover { background: #5a6268; }
        button.active { background: var(--accent-color); }

        input[type=range] { vertical-align: middle; }
        input[type=number] { width: 50px; padding: 4px; }

        .caption {
            font-size: 0.85rem;
            color: #666;
            margin-top: 0.8rem;
            font-family: -apple-system, sans-serif;
            line-height: 1.4;
        }
    </style>
</head>
<body>

    <header>
        <h1>An Intuitive Picture of Generator Matching via Resampling</h1>
        <div style="text-align: center; color: #666; margin-bottom: 2rem;">
            A Pedagogical Sketch
        </div>
    </header>

    <div class="abstract">
        <strong>Abstract.</strong> We give an intuitive description of generator matching in terms of a simple “resample–and–step” construction. Starting from conditional Markov processes indexed by a data variable $Z$, we define a hypothetical marginal process that, at each time $t$ and state $x$, resamples a fresh $Z$ from the posterior $Z \mid (X_t = x)$ and then moves one tiny step according to the corresponding conditional Markov process. We explain why this process preserves the desired marginal distributions, and why in the small–step limit it is equivalent to running a single Markov process with an <em>averaged generator</em>.
    </div>

    <section>
        <h2>1. High–level picture</h2>
        <p>Generator Matching (GM) starts from two ingredients:</p>
        <ul>
            <li>a simple “prior” distribution $p_{\text{simple}}$ (usually Gaussian);</li>
            <li>a conditional path of distributions $p_t(\cdot \mid z)$,
            interpolating between the prior and a specific data point $z$.</li>
        </ul>

        <p>The marginal generator turns out to be the appropriate <em>average</em> of the generators of the conditional processes. The goal of this note is to give an intuitive route to why this marginal generator is an average.</p>
    </section>

    <section>
        <h2>2. The Posterior Calculation</h2>
        
        <p>Define a joint model for $(Z, X_t)$: Sample $Z \sim p_{\text{data}}$, then run a conditional process $(X^z_t)$. In optimal transport flow matching, the conditional path is a straight line:
        $$ X_t = (1-t)X_0 + t Z $$
        where $X_0 \sim \mathcal{N}(0, I)$.</p>
        
        <p>To calculate the posterior $p(z \mid x, t)$, we invert this relationship. If we observe $x$ at time $t$, and we hypothesize it came from $z$, then the starting point must have been:
        $$ x_0 = \frac{x - t z}{1-t} $$
        The likelihood of $z$ is proportional to the density of the prior at this projected $x_0$.
        </p>
    </section>

    <!-- Interactive Figure 1: The Posterior -->
    <div class="interactive-figure">
        <h4 style="margin-top:0;">Viz 1: The Time-Dependent Posterior</h4>
        <canvas id="posteriorCanvas" width="600" height="450"></canvas>
        
        <div class="controls">
            <button id="btnPlayPosterior">▶ Play Time</button>
            <label>Time ($t$): <input type="range" id="timeSlider" min="0" max="99" value="50"></label>
            <span id="timeDisplay">0.50</span>
            <div style="border-left:1px solid #ccc; padding-left:10px; margin-left:10px;">
                <label>N: <input type="number" id="inputN" value="15" min="1" max="50"></label>
                <button id="btnResampleData" class="secondary">Resample Points</button>
            </div>
        </div>

        <div class="caption">
            <strong>Instructions:</strong> Move the <span style="color:green">Green Dot</span> ($x$). 
            The opacity of the <span style="color:blue">Blue Lines</span> represents the posterior probability $p(z|x,t)$.
            <br>
            The <span style="color:red">Red Arrow</span> is the posterior averaged velocity $\bar{u}_t(x)$.
            <br>
            Notice that at $t=0$, weights are based on the Prior (center). As $t \to 1$, weights depend on distance to the nearest $Z$.
        </div>
    </div>

    <section>
        <h2>3. The “resample–$Z$” marginal process</h2>

        <p>We define a hypothetical process using a simple algorithm:</p>
        <blockquote>
            Given $X^{(\Delta t)}_t = x$:
            <ol>
                <li>Sample a fresh latent $Z$ from the posterior $p(z \mid x, t)$;</li>
                <li>Evolve one tiny step towards that $Z$:
                $$ x_{new} = x + \frac{Z - x}{1-t} \Delta t $$
                </li>
            </ol>
        </blockquote>

        <p>If the step size is larger, we "hold" a specific $Z$ for longer, leading to a more "jagged" path, but as $\Delta t \to 0$, 
            the random fluctuations cancel out, and the path follows the expected velocity (the smooth average). 
        </p>
    </section>

    <!-- Interactive Figure 2: Resample vs Average -->
    <div class="interactive-figure">
        <h4 style="margin-top:0;">Viz 2: Resampling Steps vs. Averaged Flow</h4>
        <canvas id="simCanvas" width="800" height="400"></canvas>
        
        <div class="controls">
            <button id="btnResetSim">Restart Simulation</button>
            <button id="btnRandomizeSim" class="secondary">Randomize</button>
            <button id="btnToggleMode" class="active">Mode: Averaged (Smooth)</button>
        </div>
        
        <div class="controls" id="resampleControls" style="display:none; background: #eef;">
            <label>Resample Interval (Step Size): 
                <input type="range" id="stepSizeSlider" min="1" max="100" value="20">
            </label>
            <span id="stepDisplay">0.020</span>
        </div>

        <div class="caption" id="simCaption">
            <strong>Mode: Averaged.</strong> 
            <br>
            <span style="color:red; font-weight:bold;">Red Path (Hero):</span> Follows the exact posterior average.
            <br>
            <span style="color:blue">Blue Points:</span> Opacity indicates the posterior weight $p(z|x,t)$ for the Hero particle.
        </div>
    </div>

    <!-- LOGIC -->
    <script>
        // =========================================
        // UTILS & MATH
        // =========================================
        
        // Prior Distribution Parameters (Centered on Canvas)
        const PRIOR_CENTER_1 = { x: 300, y: 225 }; // Center of canvas approx
        const PRIOR_SIGMA_1 = 120; 
        const PRIOR_CENTER_2 = { x: 100, y: 200 }; // Center of canvas approx
        const PRIOR_SIGMA_2 = 60; 

        function distSq(p1, p2) {
            return (p1.x - p2.x)**2 + (p1.y - p2.y)**2;
        }

        // Gaussian PDF unnormalized
        function gaussianPdf(x, y, center, sigma) {
            const d2 = (x - center.x)**2 + (y - center.y)**2;
            return Math.exp(-d2 / (2 * sigma * sigma));
        }

        // We ignore the constant factor -log(sqrt(2pi)*sigma) because it cancels out
        function gaussianLogPdf(x, y, center, sigma) {
            const dx = x - center.x;
            const dy = y - center.y;
            // log(exp(-d^2 / 2s^2)) = -d^2 / 2s^2
            return -(dx*dx + dy*dy) / (2 * sigma * sigma);
        }

        // Replacement 2: Robust Posterior Weights using Log-Sum-Exp
        function getPosteriorWeights(x, targets, t, center, sigma) {
            // We can get extremely close to 1.0 now without NaN
            const t_safe = Math.min(t, 0.9999);
            const one_minus_t = 1 - t_safe;

            let logWeights = [];
            let maxLogW = -Infinity;

            // 1. Compute Log Weights (Project back to t=0)
            for (let z of targets) {
                const x0_x = (x.x - t_safe * z.x) / one_minus_t;
                const x0_y = (x.y - t_safe * z.y) / one_minus_t;

                const lw = gaussianLogPdf(x0_x, x0_y, center, sigma);
                logWeights.push(lw);
                
                // Track max for stability
                if (lw > maxLogW) maxLogW = lw;
            }

            // 2. Log-Sum-Exp Trick
            // We subtract maxLogW from exponents to prevent underflow to 0
            // at least one term will be exp(0) = 1
            let sumExp = 0;
            let expWeights = [];

            for (let lw of logWeights) {
                const w = Math.exp(lw - maxLogW);
                expWeights.push(w);
                sumExp += w;
            }

            // 3. Normalize
            return expWeights.map(w => w / sumExp);
        }

        function drawArrow(ctx, fromX, fromY, toX, toY, color) {
            const headlen = 10; 
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.fill();
        }

        // =========================================
        // VIZ 1: POSTERIOR FIELD
        // =========================================
        const cvs1 = document.getElementById('posteriorCanvas');
        const ctx1 = cvs1.getContext('2d');
        const timeSlider = document.getElementById('timeSlider');
        const timeDisplay = document.getElementById('timeDisplay');
        const btnPlay = document.getElementById('btnPlayPosterior');
        const inputN = document.getElementById('inputN');
        const btnResampleData = document.getElementById('btnResampleData');

        let v1 = {
            mouse: { x: 300, y: 100 },
            t: 0.5,
            targets: [],
            playing: false,
            animId: null
        };

        function initV1Data() {
            const n = parseInt(inputN.value) || 4;
            v1.targets = [];
            for(let i=0; i<n; i++){
                v1.targets.push({
                    x: Math.random() * (cvs1.width - 100) + 50,
                    y: Math.random() * (cvs1.height - 150) + 100 // Keep slightly lower
                });
            }
        }

        // Inputs
        cvs1.addEventListener('mousemove', e => {
            const r = cvs1.getBoundingClientRect();
            v1.mouse.x = e.clientX - r.left;
            v1.mouse.y = e.clientY - r.top;
        });
        cvs1.addEventListener('touchmove', e => {
            e.preventDefault();
            const r = cvs1.getBoundingClientRect();
            v1.mouse.x = e.touches[0].clientX - r.left;
            v1.mouse.y = e.touches[0].clientY - r.top;
        }, {passive:false});

        timeSlider.addEventListener('input', (e) => {
            v1.t = parseFloat(e.target.value) / 100;
            timeDisplay.textContent = v1.t.toFixed(2);
        });

        btnPlay.addEventListener('click', () => {
            v1.playing = !v1.playing;
            btnPlay.textContent = v1.playing ? "⏸ Pause" : "▶ Play Time";
        });

        btnResampleData.addEventListener('click', initV1Data);

        function loopV1() {
            if(v1.playing) {
                v1.t += 0.001;
                if(v1.t >= 1.0) v1.t = 0;
                timeSlider.value = v1.t * 100;
                timeDisplay.textContent = v1.t.toFixed(2);
            }
            drawV1();
            requestAnimationFrame(loopV1);
        }

        function drawV1() {
            ctx1.clearRect(0, 0, cvs1.width, cvs1.height);

            // Draw Prior Region (faint)
            ctx1.strokeStyle = "#eee";
            ctx1.setLineDash([5, 5]);
            ctx1.beginPath();
            ctx1.arc(PRIOR_CENTER_1.x, PRIOR_CENTER_1.y, PRIOR_SIGMA_1, 0, Math.PI*2);
            ctx1.stroke();
            ctx1.setLineDash([]);
            ctx1.fillStyle = "#ccc";
            ctx1.fillText("Prior Distribution", PRIOR_CENTER_1.x - 40, PRIOR_CENTER_1.y);

            // Compute Weights
            const weights = getPosteriorWeights(v1.mouse, v1.targets, v1.t, PRIOR_CENTER_1, PRIOR_SIGMA_1);

            // Draw Connections
            v1.targets.forEach((z, i) => {
                const w = weights[i];
                if (w > 0.001) {
                    ctx1.beginPath();
                    ctx1.moveTo(v1.mouse.x, v1.mouse.y);
                    ctx1.lineTo(z.x, z.y);
                    ctx1.strokeStyle = `rgba(0, 0, 255, ${w})`;
                    ctx1.lineWidth = w * 4 + 1;
                    ctx1.stroke();
                }
                
                // Target Dot
                ctx1.beginPath();
                ctx1.arc(z.x, z.y, 6, 0, Math.PI*2);
                ctx1.fillStyle = '#0056b3';
                ctx1.fill();
            });

            // Compute Average Velocity
            // u_t(x|z) = (z - x) / (1 - t)
            // Average = Sum w_i * (z_i - x) / (1 - t)
            let avgVx = 0, avgVy = 0;
            const t_safe = Math.min(v1.t, 0.99);
            const scale = 1 / (1 - t_safe);
            
            v1.targets.forEach((z, i) => {
                avgVx += weights[i] * (z.x - v1.mouse.x);
                avgVy += weights[i] * (z.y - v1.mouse.y);
            });
            
            // Draw Mouse
            ctx1.beginPath();
            ctx1.arc(v1.mouse.x, v1.mouse.y, 8, 0, Math.PI*2);
            ctx1.fillStyle = 'green';
            ctx1.fill();

            // Draw Velocity Vector
            const visScale = 1.0; 
            const dirX = avgVx; 
            const dirY = avgVy;
            
            drawArrow(ctx1, v1.mouse.x, v1.mouse.y, v1.mouse.x + dirX, v1.mouse.y + dirY, 'red');
        }

        initV1Data();
        loopV1();


        // =========================================
        // VIZ 2: SIMULATION
        // =========================================
        const cvs2 = document.getElementById('simCanvas');
        const ctx2 = cvs2.getContext('2d');
        const btnResetSim = document.getElementById('btnResetSim');
        const btnRandomizeSim = document.getElementById('btnRandomizeSim');
        const btnToggleMode = document.getElementById('btnToggleMode');
        const resampleControls = document.getElementById('resampleControls');
        const stepSizeSlider = document.getElementById('stepSizeSlider');
        const stepDisplay = document.getElementById('stepDisplay');
        const simCaption = document.getElementById('simCaption');
        const dt = 1 / 1000; // Slow time step

        // Fixed Targets for Sim
        const simTargets = [
            { x: 750, y: 100 }, { x: 780, y: 120 }, { x: 740, y: 130 }, 
            { x: 750, y: 280 }, { x: 780, y: 260 }, { x: 730, y: 290 }
        ];

        let sim = {
            mode: 'average', 
            running: false,
            t: 0,
            particles: [],
            initialSeeds: null,
            resampleInterval: 20,
            animId: null
        };

        function startSimFromSeeds() {
            sim.running = false;
            sim.t = 0;
            sim.particles = [];
            if (!sim.initialSeeds || sim.initialSeeds.length === 0) {
                // Safety: if seeds missing, randomize then proceed
                randomizeInitialSeeds(80);
            }
            // Instantiate particles from seeds
            for (let i = 0; i < sim.initialSeeds.length; i++) {
                const seed = sim.initialSeeds[i];
                sim.particles.push({
                    id: i,
                    x: seed.x,
                    y: seed.y,
                    history: [],
                    currentZ: null,
                    timer: 0
                });
            }

            // Restart Loop
            if(sim.animId) cancelAnimationFrame(sim.animId);
            sim.running = true;
            simLoop();
        }

        function randomizeInitialSeeds(n = 80) {
            sim.initialSeeds = [];
            for(let i=0; i<n; i++) {
                // Sample from Prior (approx) using Box-Muller
                const u = 1 - Math.random();
                const v = Math.random();
                const z_gauss = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
                const u2 = 1 - Math.random();
                const v2 = Math.random();
                const z_gauss2 = Math.sqrt( -2.0 * Math.log( u2 ) ) * Math.cos( 2.0 * Math.PI * v2 );
                sim.initialSeeds.push({
                    x: PRIOR_CENTER_2.x + z_gauss * PRIOR_SIGMA_2,
                    y: PRIOR_CENTER_2.y + z_gauss2 * PRIOR_SIGMA_2
                });
            }
        }

        function randomizeAndStartSim() {
            randomizeInitialSeeds(80);
            startSimFromSeeds();
        }

        function updateSimState() {
            if(!sim.running) return;

            sim.t += dt;
            if (sim.t >= 1.0) {
                sim.t = 1.0;
                sim.running = false;
            }

            const t = sim.t;
            const denom = Math.max(1 - t, 0.02); 

            sim.particles.forEach(p => {
                // Save Trail
                if (Math.floor(t * 400) % 3 === 0) {
                    p.history.push({x: p.x, y: p.y});
                }

                const weights = getPosteriorWeights(p, simTargets, t, PRIOR_CENTER_2, PRIOR_SIGMA_2);

                if (sim.mode === 'average') {
                    // Weighted Average Step
                    let vx = 0, vy = 0;
                    simTargets.forEach((z, i) => {
                        vx += weights[i] * (z.x - p.x);
                        vy += weights[i] * (z.y - p.y);
                    });
                    // dx = u_t * dt = (AverageVec / (1-t)) * dt
                    p.x += (vx / denom) * dt;
                    p.y += (vy / denom) * dt;
                
                } else {
                    // Resample Step
                    p.timer--;
                    if (p.timer <= 0 || !p.currentZ) {
                        p.timer = sim.resampleInterval;
                        // Sample Z
                        let r = Math.random();
                        let cum = 0;
                        p.currentZ = simTargets[simTargets.length - 1];
                        for(let i=0; i<weights.length; i++){
                            cum += weights[i];
                            if(r <= cum) {
                                p.currentZ = simTargets[i];
                                break;
                            }
                        }
                    }
                    // Step towards chosen Z
                    const vx = p.currentZ.x - p.x;
                    const vy = p.currentZ.y - p.y;
                    p.x += (vx / denom) * dt;
                    p.y += (vy / denom) * dt;
                }
            });
        }

        function drawSim() {
            ctx2.clearRect(0, 0, cvs2.width, cvs2.height);

            // Identify Hero
            const hero = sim.particles[0];

            // 1. Draw Targets (Visuals depend on Hero)
            // Calculate Hero Weights for visualization
            const heroWeights = getPosteriorWeights(hero, simTargets, sim.t, PRIOR_CENTER_2, PRIOR_SIGMA_2);

            simTargets.forEach((z, i) => {
                ctx2.beginPath();
                ctx2.arc(z.x, z.y, 6, 0, Math.PI*2);
                
                // Base Outline
                ctx2.strokeStyle = '#0056b3';
                ctx2.lineWidth = 2;
                ctx2.stroke();

                // Fill Logic
                if (sim.mode === 'average') {
                    // Opacity based on weight
                    ctx2.fillStyle = `rgba(0, 86, 179, ${heroWeights[i]})`;
                    ctx2.fill();
                } else {
                    // Resample Mode: Only highlight the one chosen by Hero
                    if (hero.currentZ === z) {
                        ctx2.fillStyle = '#0056b3';
                        ctx2.fill();
                    } else {
                        ctx2.fillStyle = 'transparent';
                        ctx2.fill();
                    }
                }
            });

            // 2. Draw Background Particles (Faded)
            ctx2.lineWidth = 1;
            for(let i=1; i<sim.particles.length; i++) {
                let p = sim.particles[i];
                if(p.history.length > 0) {
                    ctx2.beginPath();
                    ctx2.moveTo(p.history[0].x, p.history[0].y);
                    for(let pt of p.history) ctx2.lineTo(pt.x, pt.y);
                    ctx2.lineTo(p.x, p.y);
                    ctx2.strokeStyle = 'rgba(0,0,0,0.15)';
                    ctx2.stroke();
                }
            }

            // 3. Draw Hero Particle (Red, Bold)
            ctx2.lineWidth = 2.5;
            ctx2.strokeStyle = '#d63384'; // reddish
            ctx2.beginPath();
            if(hero.history.length > 0) {
                ctx2.moveTo(hero.history[0].x, hero.history[0].y);
                for(let pt of hero.history) ctx2.lineTo(pt.x, pt.y);
                ctx2.lineTo(hero.x, hero.y);
            }
            ctx2.stroke();

            ctx2.beginPath();
            ctx2.arc(hero.x, hero.y, 4, 0, Math.PI*2);
            ctx2.fillStyle = '#d63384';
            ctx2.fill();

            // Progress Bar
            ctx2.fillStyle = '#eee';
            ctx2.fillRect(0, cvs2.height - 5, cvs2.width, 5);
            ctx2.fillStyle = sim.mode === 'average' ? '#28a745' : '#d63384';
            ctx2.fillRect(0, cvs2.height - 5, cvs2.width * sim.t, 5);
        }

        function simLoop() {
            updateSimState();
            drawSim();
            if(sim.running || sim.t < 1.0) {
                sim.animId = requestAnimationFrame(simLoop);
            }
        }

        // Sim Controls
        btnResetSim.addEventListener('click', startSimFromSeeds);
        btnRandomizeSim.addEventListener('click', randomizeAndStartSim);
        
        btnToggleMode.addEventListener('click', () => {
            if(sim.mode === 'average') {
                sim.mode = 'resample';
                btnToggleMode.textContent = "Mode: Resampled (Stochastic)";
                btnToggleMode.classList.remove('active');
                resampleControls.style.display = 'flex';
                simCaption.innerHTML = `
                    <strong>Mode: Resampled.</strong> 
                    <span style="color:#d63384; font-weight:bold;">Red Path (Hero):</span> At each step, it picks the <span style="color:#0056b3; font-weight:bold">Solid Blue Target</span> and moves toward it.
                    <br/>Smaller steps $\\to$ smoother average.
                `;
            } else {
                sim.mode = 'average';
                btnToggleMode.textContent = "Mode: Averaged (Smooth)";
                btnToggleMode.classList.add('active');
                resampleControls.style.display = 'none';
                simCaption.innerHTML = `
                    <strong>Mode: Averaged.</strong> 
                    <span style="color:#d63384; font-weight:bold;">Red Path (Hero):</span> Moves by the weighted average vector.
                    <br/>
                    <span style="color:#0056b3; font-weight:bold">Blue Target Opacity</span> = Posterior weight $p(z|x,t)$.
                `;
            }
            startSimFromSeeds();
        });

        stepSizeSlider.addEventListener('input', (e) => {
            sim.resampleInterval = parseInt(e.target.value);
            stepDisplay.textContent = parseFloat(e.target.value * dt).toFixed(3);
        });

        // Click to set Hero X0 and restart
        cvs2.addEventListener('click', (e) => {
            const rect = cvs2.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (!sim.initialSeeds || sim.initialSeeds.length === 0) {
                randomizeInitialSeeds(80);
            }
            // Hero is particle 0
            sim.initialSeeds[0] = { x, y };
            startSimFromSeeds();
        });

        // Init (randomize once, then allow restarts to keep seeds)
        randomizeAndStartSim();

    </script>
</body>
</html>
